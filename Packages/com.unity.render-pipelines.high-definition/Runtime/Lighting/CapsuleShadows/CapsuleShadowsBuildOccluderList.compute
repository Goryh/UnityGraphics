#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/CapsuleShadows/CapsuleShadowsCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/ShaderVariablesCapsuleShadowsBuildTiles.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/CapsuleShadowsCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/CapsuleShadowsTiling.hlsl"

StructuredBuffer<CapsuleShadowOccluder> _CapsuleShadowOccluders;
StructuredBuffer<CapsuleShadowCaster> _CapsuleShadowCasters;
RWStructuredBuffer<CapsuleShadowVolume> _CapsuleShadowVolumes;
RWBuffer<uint> _CapsuleShadowCounters;

#define TILE_SIZE               CAPSULE_SHADOW_TILE_SIZE

uint UnpackCoordinate(inout uint index, uint length)
{
	uint next = index/length;
	uint coord = index - next*length;
	index = next;
	return coord;
}

float2 GetCoarseTileCornerCS(uint2 coarseTileCoord)
{
    uint2 upscaledPosSS = coarseTileCoord*_CapsuleCoarseTileSizeInFineTiles*TILE_SIZE;
    uint upscaleShift = (_CapsuleShadowFlags & CAPSULESHADOWFLAGS_QUARTER_RESOLUTION) ? 2 : 1;
    return ComputeClipSpacePosition(min(float2(upscaledPosSS << upscaleShift) * _CapsuleUpscaledSize.zw, 1.f), 0.f).xy;
}

bool IsLayerMaskSupportEnabled()
{
	return ((_CapsuleShadowFlags & CAPSULESHADOWFLAGS_LAYER_MASK_ENABLED) != 0);
}

bool IsCoarseCullingEnabled()
{
	return ((_CapsuleShadowFlags & CAPSULESHADOWFLAGS_USE_COARSE_CULLING) != 0);
}

[numthreads(64,1,1)]
void Main(uint workIndex : SV_DispatchThreadID)
{
	uint2 coarseTileCoord;
	coarseTileCoord.x = UnpackCoordinate(workIndex, _CapsuleRenderSizeInCoarseTilesX);
	coarseTileCoord.y = UnpackCoordinate(workIndex, _CapsuleRenderSizeInCoarseTilesY);
	uint occluderIndex = UnpackCoordinate(workIndex, _CapsuleOccluderCount);
	uint casterIndex = UnpackCoordinate(workIndex, _CapsuleCasterCount);
	uint viewIndex = workIndex;
	if (viewIndex >= _CapsuleShadowsViewCount)
		return;

    UNITY_XR_ASSIGN_VIEW_INDEX(viewIndex);
	CapsuleShadowOccluder capsule = _CapsuleShadowOccluders[occluderIndex];
	CapsuleShadowCaster caster = _CapsuleShadowCasters[casterIndex];

	// check layers
	if (IsLayerMaskSupportEnabled() && (GetLayerMask(caster) & capsule.layerMask) == 0)
		return;

	// check the capsule shadow volume intersects the light volume
	uint casterType = GetCasterType(caster);
	if (casterType == CAPSULESHADOWCASTERTYPE_POINT || casterType == CAPSULESHADOWCASTERTYPE_SPOT)
	{
		float capsuleSignedDistance = CapsuleSignedDistance(caster.positionRWS - capsule.centerRWS, capsule.offset, capsule.axisDirWS, capsule.radius);
		if (caster.lightRange < capsuleSignedDistance && IsCoarseCullingEnabled())
			return;

		// TODO: spot cone
	}

	// read coarse tile depths
    uint coarseTileIndex = CoarseTileIndex_X(coarseTileCoord);
    uint baseIndex = CAPSULE_SHADOW_COARSE_TILE_DEPTH_RANGE_BASE(coarseTileIndex);
	uint depthU0 = _CapsuleShadowCounters[baseIndex + 0];
	uint depthU1 = _CapsuleShadowCounters[baseIndex + 1];
	if (depthU0 == 0xffffffffU && IsCoarseCullingEnabled())
		return;
	float depth0 = asfloat(depthU0);
	float depth1 = asfloat(depthU1);

	// make a bounding sphere for this coarse tile
    // TODO: handle orthographic/oblique
    float linearDepth0 = LinearEyeDepth(depth0, _ZBufferParams);
    float linearDepth1 = LinearEyeDepth(depth1, _ZBufferParams);
    float4x4 invProj = UNITY_MATRIX_I_P;
    float2 viewFromClipScale = float2(invProj._m00, invProj._m11);
    float2 viewFromClipOffset = float2(invProj._m03, invProj._m13);

	float2 corner0VS_XY = GetCoarseTileCornerCS(coarseTileCoord)*viewFromClipScale + viewFromClipOffset;
	float2 corner1VS_XY = GetCoarseTileCornerCS(coarseTileCoord + 1)*viewFromClipScale + viewFromClipOffset;

	float3 centerVS = ViewspaceFromXY(.5f*(corner0VS_XY + corner1VS_XY), .5f*(linearDepth0 + linearDepth1));
	float3 cornerVS = 0.f;
	float maxDistanceSqVS = 0.f;
	[unroll]
	for (int i = 0; i < 8; ++i)
	{
		float2 checkCornerVS_XY = float2(
			((i & 1) != 0) ? corner1VS_XY.x : corner0VS_XY.x,
			((i & 2) != 0) ? corner1VS_XY.y : corner0VS_XY.y);
		float3 checkCornerVS = ViewspaceFromXY(checkCornerVS_XY, ((i & 4) != 0) ? linearDepth1 : linearDepth0);
		float3 checkOffsetVS = checkCornerVS - centerVS;
		float checkDistanceSq = dot(checkOffsetVS, checkOffsetVS);
		if (checkDistanceSq > maxDistanceSqVS)
		{
			cornerVS = checkCornerVS;
			maxDistanceSqVS = checkDistanceSq;
		}
	}
	float3 tileCenterWS = TransformViewToWorld(centerVS);
	float tileRadiusWS = length(TransformViewToWorld(cornerVS) - tileCenterWS);

	bool intersectsTile = CapsuleShadowIntersectsTile(capsule, caster, tileCenterWS, tileRadiusWS, _CapsuleIndirectRangeFactor);
	if (!intersectsTile && IsCoarseCullingEnabled())
		return;

	// keep the capsule, write to the list for this coarse tile (shared by all tiles within it during fine tiling)
	uint volumeIndex;
	InterlockedAdd(_CapsuleShadowCounters[CAPSULE_SHADOW_COARSE_TILE_SHADOW_COUNT(coarseTileIndex)], 1, volumeIndex);
	_CapsuleShadowVolumes[CAPSULE_SHADOW_GLOBAL_INDEX(coarseTileIndex, volumeIndex)] = makeCapsuleShadowVolume(occluderIndex, casterIndex, casterType);
}
